<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>UI Chat</title>
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9"
            crossorigin="anonymous"
        />
        <style>
            html,
            body {
                height: 100%;
                margin: 0;
                overflow: hidden;
            }

            .chat-wrapper {
                display: flex;
                flex-direction: column;
                height: 100vh;
                background-color: #f8f9fa;
            }

            .chatHeaderContainer {
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 1px solid #ccc;
                padding: 0.75rem 1.5rem;
                background-color: #fff;
                flex-shrink: 0;
            }

            h2 {
                margin: 0;
                font-size: 1.25rem;
            }

            .chat-box {
                flex-grow: 1;
                overflow-y: auto;
                padding: 1rem 1.5rem;
            }

            .user-message,
            .bot-message {
                margin-bottom: 1rem;
                padding: 0.5rem 1rem;
                border-radius: 12px;
                max-width: 80%;
            }
            .user-message {
                background-color: #007bff;
                color: white;
                margin-left: auto;
            }
            .bot-message {
                background-color: #e9ecef;
                color: #333;
                margin-right: auto;
            }

            .chat-input-container {
                padding: 1rem 1.5rem;
                border-top: 1px solid #ccc;
                background-color: #fff;
                flex-shrink: 0;
            }

            button {
                margin-right: 1em;
            }

            #mic-btn {
                position: absolute;
                right: 42px;
                top: 50%;
                transform: translateY(-50%);
                border: none;
                background-color: transparent;
                cursor: pointer;
                padding: 8px;
                font-size: 18px;
                color: #555;
            }

            #mic-btn:hover {
                color: #000;
            }

            #mic-btn.is-listening {
                color: #d90429;
                animation: pulse 1.5s infinite;
            }

            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 100;
                display: none;
            }
            .modal {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 2rem;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                z-index: 101;
                width: 90%;
                max-width: 400px;
                display: none;
            }
            .modal.active,
            .modal-overlay.active {
                display: block;
            }
            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 1px solid #eee;
                margin-bottom: 1rem;
                padding-bottom: 1rem;
            }
            .modal-header h2 {
                margin: 0;
            }
            .close-btn {
                font-size: 1.5rem;
                background: none;
                border: none;
                cursor: pointer;
            }
            .modal-body .control-group {
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
                margin-bottom: 1rem;
            }
            .modal-body label {
                font-weight: bold;
            }
            .modal-body select {
                width: 100%;
                padding: 0.5rem;
                font-size: 1rem;
                border-radius: 4px;
                border: 1px solid #ccc;
            }

            .modal-body .control-group-row {
                flex-direction: row;
                align-items: center;
                gap: 0.75rem;
            }
            .modal-body .control-group-row label {
                font-weight: normal;
            }
        </style>
    </head>
    <body>
        <div id="chatUI"></div>
        <div id="settingsModalOverlay" class="modal-overlay"></div>
        <div id="settingsModal" class="modal">
            <div class="modal-header">
                <h2>Einstellungen</h2>
                <button id="closeModalBtn" class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="control-group">
                    <label for="languageSelect">Sprache:</label>
                    <select id="languageSelect"></select>
                </div>
                <div class="control-group">
                    <label for="voiceSelect">Stimmen:</label>
                    <select id="voiceSelect"></select>
                </div>
                <div class="control-group control-group-row">
                    <input type="checkbox" id="readBackCheckbox" checked />
                    <label for="readBackCheckbox">Antwort vorlesen</label>
                </div>
                <h3>Datenquelle</h3>
                <div class="control-group control-group-row">
                    <input type="checkbox" id="weather" checked />
                    <label for="weather">Wetter</label>
                    <input type="checkbox" id="KIS" checked />
                    <label for="KIS">Patienten</label>
                    <input type="checkbox" id="events" checked />
                    <label for="events">Events</label>
                </div>
            </div>
        </div>
        <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
            crossorigin="anonymous"
        ></script>
        <script>
            const VIYAHOST = window.parent.origin;
            const languageSelect = document.getElementById("languageSelect");
            const voiceSelect = document.getElementById("voiceSelect");
            const readBackCheckbox =
                document.getElementById("readBackCheckbox");
            const weatherDataCheckbox = document.getElementById("weather");
            const KISDataCheckbox = document.getElementById("KIS");
            const eventDataCheckbox = document.getElementById("event");
            const modal = document.getElementById("settingsModal");
            const overlay = document.getElementById("settingsModalOverlay");
            const closeModalBtn = document.getElementById("closeModalBtn");
            let sasSessionID = "";
            let apiKey = "";

            const languages = {
                "de-DE": "Deutsch (Deutschland)",
                "en-US": "English (US)",
            };
            const SpeechRecognition =
                window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = SpeechRecognition
                ? new SpeechRecognition()
                : null;
            const synthesis = window.speechSynthesis || null;
            let voices = [];
            function openModal() {
                modal.classList.add("active");
                overlay.classList.add("active");
            }
            function closeModal() {
                modal.classList.remove("active");
                overlay.classList.remove("active");
            }
            closeModalBtn.addEventListener("click", closeModal);
            overlay.addEventListener("click", closeModal);
            function populateLanguageList() {
                for (const [code, name] of Object.entries(languages)) {
                    const option = document.createElement("option");
                    option.value = code;
                    option.textContent = name;
                    languageSelect.appendChild(option);
                }
            }
            function populateVoiceList() {
                voices = synthesis.getVoices();
                voiceSelect.innerHTML = "";
                const selectedLanguage = languageSelect.value;
                const filteredVoices = voices.filter((voice) =>
                    voice.lang.startsWith(selectedLanguage)
                );
                for (const voice of filteredVoices) {
                    const option = document.createElement("option");
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.setAttribute("data-name", voice.name);
                    voiceSelect.appendChild(option);
                }
            }
            if (synthesis) {
                synthesis.onvoiceschanged = populateVoiceList;
            }
            languageSelect.addEventListener("change", populateVoiceList);
            populateLanguageList();

            if (window.addEventListener) {
                window.addEventListener("message", onMessage, false);
            } else {
                window.attachEvent("onmessage", onMessage);
            }

            let agentTree = [];

            function callGemini(userInput) {
                const MODEL_ID = "gemini-2.5-flash";
                const GENERATE_CONTENT_API = "generateContent";
                const URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_ID}:${GENERATE_CONTENT_API}?key=${apiKey}`;

                const requestBody = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                {
                                    text: userInput,
                                },
                            ],
                        },
                    ],
                    generationConfig: {
                        thinkingConfig: {
                            thinkingBudget: -1,
                        },
                    },
                };

                return fetch(URL, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(requestBody),
                })
                    .then((response) => {
                        if (!response.ok) {
                            throw new Error(
                                `HTTP error! status: ${response.status}`
                            );
                        }
                        console.log(response);
                        return response.json();
                    })
                    .then((data) => {
                        console.log(data);
                        return data.candidates[0].content.parts[0].text;
                    })
                    .catch((error) => {
                        return false;
                    });
            }

            function addChatWithDataObject(
                chatWithDataObject,
                paneID,
                chatWithDataInterfaceText
            ) {
                const chatWrapper = document.createElement("div");
                chatWrapper.classList.add("chat-wrapper");
                chatWrapper.id = `${paneID}-obj-${chatWithDataObject?.id}-wrapper`;

                // 1. HEADER (Top, non-scrolling part)
                const chatHeaderContainer = document.createElement("div");
                chatHeaderContainer.className = "chatHeaderContainer";
                const chatHeader = document.createElement("h2");
                chatHeader.innerText = chatWithDataInterfaceText?.chatHeader;
                const settingsButton = document.createElement("button");
                settingsButton.id = "settingsBtn";
                settingsButton.className = "btn btn-light";
                settingsButton.innerText = "âš™";
                settingsButton.addEventListener("click", openModal);
                chatHeaderContainer.appendChild(chatHeader);
                chatHeaderContainer.appendChild(settingsButton);
                chatWrapper.appendChild(chatHeaderContainer);

                // 2. CHAT BOX (Middle, scrolling part)
                const chatBoxContainer = document.createElement("div");
                chatBoxContainer.id = `${paneID}-obj-${chatWithDataObject?.id}-chat-box`;
                chatBoxContainer.className = "chat-box";
                chatWrapper.appendChild(chatBoxContainer);
                const chatOpeningMessage = document.createElement("div");
                chatOpeningMessage.id = `${paneID}-obj-${chatWithDataObject?.id}-message-0`;
                chatOpeningMessage.className = "bot-message";
                chatOpeningMessage.innerText =
                    "Hallo, ich bin KAI und kann Ihnen dabei helfen Fragen zu beantworten. Sie kÃ¶nnen die verfÃ¼gbaren Daten Ã¼ber die Einstellungen einschrÃ¤nken. Bitte beachten Sie das ich eine KI bin und entsprechend Fehler machen kann.";
                chatBoxContainer.appendChild(chatOpeningMessage);

                // 3. INPUT AREA (Bottom, non-scrolling part)
                const chatInputContainer = document.createElement("div");
                chatInputContainer.id = `${paneID}-obj-${chatWithDataObject?.id}-chat-container`;
                chatInputContainer.className = "chat-input-container";

                const chatInputGroup = document.createElement("div");
                chatInputGroup.className = "input-group";
                chatInputContainer.appendChild(chatInputGroup);

                const chatUserInput = document.createElement("input");
                chatUserInput.type = "text";
                chatUserInput.id = `${paneID}-obj-${chatWithDataObject?.id}-user-input`;
                chatUserInput.className = "form-control";
                chatUserInput.placeholder =
                    chatWithDataInterfaceText?.placeholder;
                chatUserInput.onkeydown = handleKeyPress;
                chatInputGroup.appendChild(chatUserInput);

                const micButton = document.createElement("button");
                micButton.id = "mic-btn";
                micButton.title = "Voice input";
                micButton.innerText = "ðŸŽ¤";
                chatInputGroup.appendChild(micButton);

                if (recognition && synthesis) {
                    recognition.continuous = false;

                    micButton.addEventListener("click", () => {
                        recognition.lang = languageSelect.value;
                        console.log(
                            `Status: Listening in ${
                                languages[languageSelect.value]
                            }...`
                        );
                        micButton.disabled = true;
                        micButton.classList.add("listening");
                        recognition.start();
                    });

                    recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        chatUserInput.value = transcript;
                    };

                    recognition.onend = () => {
                        console.log("Status: Idle");
                        micButton.disabled = false;
                        micButton.classList.remove("listening");
                    };

                    recognition.onerror = (event) => {
                        console.log(`Error: ${event.error}`);
                        micButton.disabled = false;
                        micButton.classList.remove("listening");
                    };
                }

                const sendButton = document.createElement("button");
                sendButton.className = "btn btn-primary";
                sendButton.onclick = sendMessage;
                chatInputGroup.appendChild(sendButton);

                const sendIcon = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "svg"
                );
                sendIcon.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                sendIcon.setAttribute("width", "24");
                sendIcon.setAttribute("height", "24");
                sendIcon.setAttribute("viewBox", "0 0 24 24");
                sendIcon.setAttribute("fill", "white");
                sendButton.appendChild(sendIcon);

                const sendIconPath = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "path"
                );
                sendIconPath.setAttribute(
                    "d",
                    "M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"
                );
                sendIcon.appendChild(sendIconPath);

                chatWrapper.appendChild(chatInputContainer);

                function printUserMessage(message) {
                    const chatBox = document.getElementById(
                        `${paneID}-obj-${chatWithDataObject?.id}-chat-box`
                    );
                    const userDiv = document.createElement("div");
                    userDiv.className = "user-message";
                    userDiv.textContent = message;
                    chatBox.appendChild(userDiv);
                    scrollToBottom();
                }

                async function runUserAction(buttonDefinitionObject) {
                    switch (buttonDefinitionObject.keyword) {
                        case "link":
                            window.open(buttonDefinitionObject.link, "_blank");
                            break;
                        default:
                            console.log(buttonDefinitionObject.keyword);
                    }
                }

                function printBotMessage(botMessage) {
                    const chatBox = document.getElementById(
                        `${paneID}-obj-${chatWithDataObject?.id}-chat-box`
                    );
                    const botDiv = document.createElement("div");
                    botDiv.className = "bot-message";
                    botDiv.textContent = botMessage.text;

                    let buttons = botMessage.buttons;
                    if (buttons && buttons.length > 0) {
                        const buttonContainer = document.createElement("div");
                        buttonContainer.className = "mt-2";
                        buttons.forEach((buttonObject) => {
                            const button = document.createElement("button");
                            button.className =
                                "btn btn-outline-primary btn-sm me-2";
                            button.textContent = buttonObject.text;
                            button.onclick = () => runUserAction(buttonObject);
                            buttonContainer.appendChild(button);
                        });
                        botDiv.appendChild(buttonContainer);
                    }

                    chatBox.appendChild(botDiv);
                    scrollToBottom();

                    let delayMessage = botMessage.delayMessage;
                    if (delayMessage && delayMessage.length > 0) {
                        setTimeout(() => {
                            printBotMessage(delayMessage[0]);
                        }, botMessage.delay * 1000);
                    }
                }

                let messageCounter = 0;

                /**
                 * Filters questions and answers by category and returns them as a semicolon-separated string.
                 * @param {Array<Object>} data - The dataset of questions, answers, and categories.
                 * @param {string} category - The category to filter by.
                 * @returns {string} A semicolon-separated string of the filtered questions and answers.
                 */
                function getQAsByCategory(data, category) {
                    return data.filter(
                        (item) => item.dataSetName === category
                    )[0];
                }

                const dataSet = [
                    {
                        dataSetName: "df_patients",
                        description: "Contains the number of patients per date",
                        columns: [
                            {
                                name: "current_date",
                                description: "The date value",
                                is_primary: "yes",
                            },
                            {
                                name: "number_of_patients",
                                description:
                                    "Number of patients for the specific date",
                            },
                        ],
                    },
                    {
                        dataSetName: "df_events",
                        description:
                            "Contains information about public holidays, school vacation and other major events in Frankfurt per day",
                        columns: [
                            {
                                name: "dautm",
                                description: "The date value",
                                is_primary: "yes",
                            },
                            { name: "Name", description: "Name of the event" },
                            {
                                name: "Anzahl_Teilnehmer",
                                description:
                                    "Number of attendees - only applies for major events not holidays/vacation",
                            },
                        ],
                    },
                    {
                        dataSetName: "df_weather",
                        description:
                            "Contains information about the daily weather in Frankfurt",
                        columns: [
                            {
                                name: "date",
                                description: "The date value",
                                is_primary: "yes",
                            },
                            {
                                name: "tavg",
                                description:
                                    "Average daily temperature in Celsius",
                            },
                            {
                                name: "tmax",
                                description:
                                    "The max temperature of that day in Celsius",
                            },
                        ],
                    },
                ];

                function sendMessage() {
                    const userInput = document.getElementById(
                        `${paneID}-obj-${chatWithDataObject?.id}-user-input`
                    );
                    const message = userInput.value;
                    if (message.trim() !== "") {
                        let context = [];

                        context.push(
                            weatherDataCheckbox
                                ? getQAsByCategory(dataSet, "df_weather")
                                : null
                        );
                        context.push(
                            KISDataCheckbox
                                ? getQAsByCategory(dataSet, "df_patients")
                                : null
                        );
                        context.push(
                            eventDataCheckbox
                                ? getQAsByCategory(dataSet, "df_events")
                                : null
                        );
                        printUserMessage(message);
                        console.log(context);
                        let prompt = `You are an expert in analyzing the users question and translating that into Pyhton that can make use of the pandas package as pd and numpy as np. Here is the context from which you can answer questions: ${JSON.stringify(
                            context.filter((n) => n)
                        )}
        Answer Format: Only respond with the following JSON object: {reason: "Reasoning that explains on a high level what the code will do without mentioning withings like the dataframe names in the users input langauge", code: ["each Python code line is one element"]} If answering is not possible from the given context set the reason to: "Answering is not possible with the current context" in the users language, make sure that the answer reason text is always in the users language. The answer always has to be put into a dataframe called df_result.
        USER'S QUESTION: "${message}"`;
                        callGemini(prompt).then((res) => {
                            const cleanString = res.replace(
                                /^```json\s+|\s+```$/g,
                                ""
                            );
                            const parsedObject = JSON.parse(cleanString);
                            const botMessage = parsedObject.reason
                                .replace('"', "")
                                .replace("'", "")
                                .replace("`", "");

                            printBotMessage({ text: botMessage });
                            if (readBackCheckbox.checked) {
                                const utterance = new SpeechSynthesisUtterance(
                                    botMessage
                                );
                                const selectedOption =
                                    voiceSelect.selectedOptions[0]?.getAttribute(
                                        "data-name"
                                    );
                                if (selectedOption) {
                                    const selectedVoice = voices.find(
                                        (voice) => voice.name === selectedOption
                                    );
                                    if (selectedVoice) {
                                        utterance.voice = selectedVoice;
                                    }
                                }
                                synthesis.speak(utterance);
                            }

                            if (parsedObject.code.length > 0) {
                                let postCode = [
                                    "SAS.df2sd(df_result, 'work.result')",
                                    "endsubmit;",
                                    "quit;",
                                    "options noDate noNumber;",
                                    "proc report data=work.result noHeader;",
                                    "quit;",
                                ];
                                let submittableCode = [
                                    "proc python;",
                                    "submit;",
                                ];
                                submittableCode.push(...parsedObject.code);
                                submittableCode.push(...postCode);
                                submitSASCode(submittableCode).then(
                                    (result) => {
                                        fetchListing(result).then(
                                            (codeResponse) => {
                                                let responsePrompt = `You are an expert in explaining the returned outputs that where generated by the following code ${parsedObject.code}. Here are the results from running that code: ${codeResponse}. Do not mention any of the technical details behind that code rather provide a high level short and to the point answer based on the users initial in the language that the user ask the question: ${message}`;
                                                callGemini(responsePrompt).then(
                                                    (finalResponse) => {
                                                        printBotMessage({
                                                            text: finalResponse,
                                                        });
                                                        if (
                                                            readBackCheckbox.checked
                                                        ) {
                                                            const utterance =
                                                                new SpeechSynthesisUtterance(
                                                                    finalResponse
                                                                );
                                                            const selectedOption =
                                                                voiceSelect.selectedOptions[0]?.getAttribute(
                                                                    "data-name"
                                                                );
                                                            if (
                                                                selectedOption
                                                            ) {
                                                                const selectedVoice =
                                                                    voices.find(
                                                                        (
                                                                            voice
                                                                        ) =>
                                                                            voice.name ===
                                                                            selectedOption
                                                                    );
                                                                if (
                                                                    selectedVoice
                                                                ) {
                                                                    utterance.voice =
                                                                        selectedVoice;
                                                                }
                                                            }
                                                            synthesis.speak(
                                                                utterance
                                                            );
                                                        }
                                                    }
                                                );
                                            }
                                        );
                                    }
                                );
                            }
                        });
                        userInput.value = "";
                    }
                }

                function handleKeyPress(event) {
                    if (event.keyCode === 13) {
                        sendMessage();
                    }
                }

                function scrollToBottom() {
                    const chatBox = document.getElementById(
                        `${paneID}-obj-${chatWithDataObject?.id}-chat-box`
                    );
                    chatBox.scrollTop = chatBox.scrollHeight;
                }

                return chatWrapper;
            }

            async function getSASJobState(jobID) {
                let state = await fetch(
                    `${VIYAHOST}/compute/sessions/${sasSessionID}/jobs/${jobID}/state`,
                    {
                        // mode: 'no-cors',
                        method: "get",
                        headers: {
                            Accept: "text/plain",
                        },
                        credentials: "include",
                        redirect: "follow",
                    }
                );

                return await state.text();
            }

            async function submitSASCode(code) {
                let sasCodeBody = JSON.stringify({
                    code: code,
                    attributes: { resetLogLinesNumbers: true },
                });

                let sasCodeResponse = await fetch(
                    `${VIYAHOST}/compute/sessions/${sasSessionID}/jobs`,
                    {
                        // mode: 'no-cors',
                        method: "post",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRF-TOKEN":
                                document?.csrfToken != undefined
                                    ? document.csrfToken
                                    : "",
                        },
                        credentials: "include",
                        body: sasCodeBody,
                    }
                );
                if (!sasCodeResponse.ok) {
                    if (
                        sasCodeResponse.status === 403 &&
                        sasCodeResponse.headers.get("x-forbidden-reason") ===
                            "CSRF"
                    ) {
                        let h = sasCodeResponse.headers.get("x-csrf-header");
                        let t = sasCodeResponse.headers.get("x-csrf-token");
                        document.csrfToken = t;
                        sasCodeResponse = await fetch(
                            `${VIYAHOST}/compute/contexts/${computeContextID}/sessions`,
                            {
                                // mode: 'no-cors',
                                method: "post",
                                headers: {
                                    "Content-Type": "application/json",
                                    "X-CSRF-TOKEN":
                                        document?.csrfToken != undefined
                                            ? document.csrfToken
                                            : "",
                                },
                                credentials: "include",
                                body: sasCodeBody,
                            }
                        );
                    }
                }

                let codeResponse = await sasCodeResponse.json();
                let codeResponseID = codeResponse.id;

                let isJobComplete = [
                    "completed",
                    "canceled",
                    "warning",
                    "error",
                ];
                let currenJobStatus = "running";
                const delay = (ms) => new Promise((res) => setTimeout(res, ms));
                while (!isJobComplete.includes(currenJobStatus)) {
                    await delay(2000);
                    currenJobStatus = await getSASJobState(codeResponseID);
                }

                return codeResponseID;
            }

            async function fetchListing(jobID) {
                const listingResponse = await fetch(
                    `${VIYAHOST}/compute/sessions/${sasSessionID}/jobs/${jobID}/listing`,
                    {
                        // mode: 'no-cors',
                        method: "get",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        credentials: "include",
                    }
                );
                const listingJSON = await listingResponse.json();
                const resultLong = listingJSON.items.filter(
                    (item) => item.type === "normal"
                );
                const result = resultLong
                    .map((item) => item.line.trim())
                    .join(", ");
                return result;
            }

            async function sasSession(
                contextName = "SAS Job Execution compute context"
            ) {
                /* 
                        1. Get the ID of the Compute Context
                        2. Start a SAS Session
                    */
                const computeContextResponse = await fetch(
                    `${VIYAHOST}/compute/contexts?filter=eq(name,'${contextName}')`,
                    {
                        // mode: 'no-cors',
                        method: "get",
                        headers: {
                            "X-Requested-With": "XMLHttpRequest",
                            Accept: "application/json",
                        },
                        credentials: "include",
                    }
                );
                const computeContext = await computeContextResponse.json();
                const computeContextID = computeContext.items[0].id;

                let requestBody = JSON.stringify({
                    version: 1,
                    name: "KAI",
                    description: "The session of KAI",
                    attributes: {
                        sessionInactiveTimeout: 60,
                    },
                    environment: {
                        autoExecLines: [
                            "filename init filesrvc folderPath='/Public/KAI' fileName='KAI-Setup.sas';",
                        ],
                    },
                });
                const sessionResponse = await fetch(
                    `${VIYAHOST}/compute/contexts/${computeContextID}/sessions`,
                    {
                        // mode: 'no-cors',
                        method: "post",
                        headers: {
                            "Content-Type": "application/json",

                            "X-CSRF-TOKEN":
                                document?.csrfToken != undefined
                                    ? document.csrfToken
                                    : "",
                        },
                        credentials: "include",
                        body: requestBody,
                    }
                );

                if (!sessionResponse.ok) {
                    if (
                        sessionResponse.status === 403 &&
                        sessionResponse.headers.get("x-forbidden-reason") ===
                            "CSRF"
                    ) {
                        let h = sessionResponse.headers.get("x-csrf-header");
                        let t = sessionResponse.headers.get("x-csrf-token");
                        document.csrfToken = t;
                        sessionResponse = await fetch(
                            `${VIYAHOST}/compute/contexts/${computeContextID}/sessions`,
                            {
                                // mode: 'no-cors',
                                method: "post",
                                headers: {
                                    "Content-Type": "application/json",
                                    "X-CSRF-TOKEN": t,
                                },
                                credentials: "include",
                                body: requestBody,
                            }
                        );
                    }
                }

                let sessionContext = await sessionResponse.json();
                sasSessionID = sessionContext.id;
                submitSASCode(["%include init;"]);
            }

            function onMessage(event) {
                if (event && event.data) {
                    apiKey = event.data.parameters[0].value;

                    // Reset chat UI
                    document.getElementById("chatUI").innerHTML = "";
                    // Init new UI instance
                    let result = addChatWithDataObject({ id: "main" }, "main", {
                        placeholder: "Wie hoch ist die aktuelle Auslastung?",
                        chatHeader: "Klinik Chatbot KAI",
                    });
                    document.getElementById("chatUI").appendChild(result);
                    // Start SAS Session
                    sasSession();
                }
            }
        </script>
    </body>
</html>
